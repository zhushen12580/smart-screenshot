<!-- Generated by SpecStory -->

# 长截图Chrome插件开发 (2025-05-09 06:00Z)

_**User**_



---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants to implement a "scrolling screenshot" feature in their Chrome extension. I need to analyze the existing code (`content/content.js`, `background/background.js`, `popup/popup.js`) to understand the current architecture and UI style, and then propose a solution that integrates seamlessly.

Here's a plan:

1.  **Understand Existing Code:**
    *   `content.js`: Handles the in-page UI for selecting an area, toolbar, etc. It communicates with `background.js` for capturing and saving. It already has logic for `captureFullPage` which seems to be a starting point.
    *   `background.js`: Manages messages, triggers captures (`captureVisibleTab`, a `captureFullPageByTiles` function), saves files, and handles API calls. The `captureFullPageByTiles` function is highly relevant.
    *   `popup.js`: Provides the UI for initiating screenshots and configuring options.

2.  **Design the Scrolling Screenshot Feature:**
    *   **User Interaction:**
        *   A new button in the popup, possibly "滚动截屏" (Scrolling Screenshot).
        *   When clicked, the content script should activate.
        *   The user might need to define the scrollable area, or the script could try to auto-detect it. Given the request for "一定的智能程度", auto-detection or a guided selection would be good.
        *   The script will then scroll the page, take multiple screenshots, and stitch them together.
    *   **Intelligence:**
        *   **Auto-detect scrollable area:** This is tricky. Maybe start with the whole document body or a large scrollable container.
        *   **Smart scrolling:** Scroll by a fixed amount (e.g., viewport height - overlap) or detect the end of content.
        *   **Overlap:** Ensure some overlap between captures for better stitching.
        *   **Stitching:** This will be the most complex part. The `background.js` already has `mergeAndProcessTiles` which is a great starting point.
    *   **Integration:**
        *   Modify `popup.js` to add the new button and logic.
        *   Modify `content.js` to handle the scrolling screenshot initiation and UI (if any specific UI is needed beyond the existing selection/toolbar). It will need to orchestrate the scrolling and capturing.
        *   Modify `background.js` to enhance `captureFullPageByTiles` or create a new function specifically for user-initiated scrolling screenshots. It needs to receive commands to scroll, capture, and then stitch.

3.  **Step-by-step Implementation Thoughts:**

    *   **`popup.js` Changes:**
        *   Add a "滚动截屏" button.
        *   When clicked, send a message to `background.js` (e.g., `action: 'startScrollingScreenshot'`).

    *   **`background.js` Changes:**
        *   Handle `startScrollingScreenshot` message.
        *   Inject `content.js` if not already injected.
        *   Send a message to `content.js` to initiate the scrolling capture UI/logic (e.g., `action: 'initiateScrollingCapture'`).
        *   The existing `captureFullPageByTiles` logic seems like a good candidate to be reused or adapted. The main difference is that for a user-defined scrolling screenshot, the `targetArea` might be dynamically determined by the scrolling process itself rather than being predefined.
        *   The core challenge in `background.js` will be to manage the sequence:
            1.  Tell content script to scroll.
            2.  Wait for scroll completion.
            3.  Tell content script (or directly) to capture visible tab.
            4.  Repeat until done.
            5.  Stitch images.

    *   **`content.js` Changes:**
        *   Listen for `initiateScrollingCapture`.
        *   **Phase 1: (Optional) Area Selection for Scrolling:**
            *   The user could click on the element they want to scroll and capture. Or, it could default to the main document scroll.
            *   A simple approach: when "Scrolling Screenshot" is initiated, the user hovers and clicks the scrollable element.
        *   **Phase 2: Scrolling and Capturing Loop:**
            *   Determine the scrollable element (e.g., `document.documentElement` or a user-selected one).
            *   Get initial scroll position and viewport dimensions.
            *   **Loop:**
                *   Send message to `background.js` to `captureVisibleTab`.
                *   Receive `dataUrl` from `background.js`. Store it.
                *   Scroll the element down by `viewportHeight - overlap`.
                *   Check if the scroll position changed significantly or if the bottom is reached.
                *   If more content, repeat.
            *   **End Condition:**
                *   `element.scrollTop + element.clientHeight >= element.scrollHeight` (or very close).
                *   No significant change in `scrollTop` after a scroll attempt.
        *   **Phase 3: Send Data to Background for Stitching:**
            *   Send all captured `dataUrl`s and their scroll positions/dimensions to `background.js`.
        *   **UI during scrolling:**
            *   Display a "Capturing scrollable area..." notification.
            *   Possibly hide the toolbar or other screenshot UI elements temporarily.

    *   **Stitching Logic (in `background.js` - adapting `mergeAndProcessTiles`):**
        *   The `mergeAndProcessTiles` function currently takes `targetArea` and `tilesInfo`. This will need to be adapted. Instead of predefined tiles, it will receive a sequence of full viewport captures and their scroll offsets.
        *   The canvas in `mergeAndProcessTiles` needs to be tall enough for the full stitched image. The total height can be estimated from the scroll distance.
        *   When drawing each image onto the main canvas, the `y` offset will be crucial. It will be `current_scroll_position_of_capture - initial_scroll_position_of_first_capture`.
        *   Handle overlap: The captures will have overlap. The stitching logic needs to account for this. A simple way is to just draw them sequentially, but smarter stitching might try to find common features to align (though this is much more complex). For now, sequential drawing with a known overlap might be sufficient. The existing `captureFullPageByTiles` tries to calculate `srcX, srcY, srcWidth, srcHeight` for each tile. A similar logic will be needed.

Let's refine the intelligence part for scrolling and stopping:

*   **Scrollable Element:**
    *   Default: `document.documentElement`.
    *   Advanced: Allow user to click/select a scrollable div. `content.js` can use the inspector-like hover to highlight elements, and on click, identify that as the scroll target.
*   **Scrolling Increment:** `viewportHeight - overlap` (e.g., `overlap = 50` pixels).
*   **Stopping Condition:**
    1.  The scrollable element's `scrollTop` doesn't change after a scroll attempt (or changes by a very small amount).
    2.  `element.scrollTop + element.clientHeight` is very close to `element.scrollHeight`.
    3.  A maximum number of scrolls to prevent infinite loops (e.g., 20-30 scrolls).

**Revised Plan for `background.js` and `content.js` interaction for scrolling screenshots:**

1.  **`popup.js`:**
    *   Button "滚动截屏".
    *   On click, sends `action: 'initiateScrollingScreenshot'` to `content.js` (after injecting it via `background.js` if needed).

2.  **`content.js`:**
    *   Receives `initiateScrollingScreenshot`.
    *   (Optional: Enters a mode to let the user select the scrollable element. For now, let's assume `document.documentElement` or `document.body` as the primary scroll target).
    *   Displays a "正在准备滚动截图..." notification.
    *   Determines the scrollable element.
    *   Sends `action: 'startScrollCaptureSequence'` to `background.js` with initial info: `elementScrollHeight`, `elementClientHeight`, `viewportWidth`, `viewportHeight`, `devicePixelRatio`.
    *   **`handleScrollAndCapture` (new function in `content.js`):**
        *   Receives `action: 'doScrollAndCapture'` from `background.js`.
        *   Captures current visible part (sends `action: 'captureVisibleTab'` to `background.js`).
        *   On response from `background.js` with `dataUrl`:
            *   Stores `dataUrl` and current `scrollTop` locally.
            *   Scrolls the element down by `viewportHeight - overlap`.
            *   Waits a brief moment for rendering (e.g., 200-300ms).
            *   Checks stop conditions.
            *   Sends `action: 'scrollAndCaptureDone'` to `background.js` with:
                *   `dataUrl`
                *   `scrollTop` (before this scroll)
                *   `isFinished` (boolean)
                *   `newScrollTop` (after this scroll)

3.  **`background.js`:**
    *   Receives `startScrollCaptureSequence` from `content.js`. Stores initial info.
    *   Sends `action: 'doScrollAndCapture'` to `content.js` to kick off the first capture.
    *   Receives `scrollAndCaptureDone` from `content.js`:
        *   Stores the `dataUrl` and its `scrollTop`.
        *   If `isFinished` is true OR `newScrollTop` is same as `scrollTop` (or very close):
            *   Proceed to stitch all collected images.
            *   The stitching logic will be similar to `mergeAndProcessTiles` but adapted for sequential full-viewport images with known scroll offsets.
            *   The total height of the canvas for stitching will be `lastScrollTop + viewportHeight - initialScrollTop`.
            *   Each image is drawn at `(0, scrollTopOfThisImage - initialScrollTop)`.
            *   After stitching, save the image.
        *   If `isFinished` is false and scroll happened:
            *   Sends `action: 'doScrollAndCapture'` to `content.js` again to continue the sequence.

This seems like a more robust way to coordinate between content and background for the scrolling and capturing loop.

**Detailed considerations for stitching in `background.js`:**
The `mergeAndProcessTiles` function is designed for a grid of tiles. For scrolling screenshots, we have a series of vertical strips.

Let `captures` be an array of objects: `{ dataUrl, scrollTop }`.
Sort `captures` by `scrollTop`.
`initialScrollTop = captures[0].scrollTop`.
`finalScrollTop = captures[captures.length - 1].scrollTop`.
Assume `viewportHeight` and `devicePixelRatio (dpr)` are known.

Total height of the stitched image:
`totalCanvasHeight = (finalScrollTop + viewportHeight - initialScrollTop) * dpr`.
Total width: `canvasWidth = viewportWidth * dpr`.

Create a canvas: `stitchedCanvas.width = canvasWidth; stitchedCanvas.height = totalCanvasHeight;`
Iterate through `captures`:
For each `capture = { dataUrl, scrollTop }`:
  Load `dataUrl` into an `Image` object.
  `drawY = (capture.scrollTop - initialScrollTop) * dpr`.
  The captured image is `img.width = viewportWidth * dpr`, `img.height = viewportHeight * dpr`.
  `ctx.drawImage(img, 0, 0, img.width, img.height, 0, drawY, img.width, img.height)`.
  This basic drawing assumes no overlap handling. If there's overlap, the last drawn image will cover the previous one in the overlap region. This is usually acceptable.

The `captureFullPageByTiles` logic in `background.js` already does scrolling and capturing in sequence, and then stitches. It might be more efficient to adapt this.
The key differences:
1.  **Scroll Target:** Scrolling screenshot will scroll the main window or a user-defined element vertically. `captureFullPageByTiles` scrolls in a grid.
2.  **Capture Unit:** Scrolling screenshot captures `viewportHeight` strips. `captureFullPageByTiles` captures `effectiveHeight` strips.
3.  **End Condition:** Scrolling screenshot stops when the scrollable content ends. `captureFullPageByTiles` stops when the `targetArea` is covered.

Let's adapt `captureFullPageByTiles` to a new function `captureScrollingPage`.

**`background.js` - New Function: `startScrollingCaptureProcess`**

```javascript
// Simplified conceptual flow
let collectedScrollCaptures = [];
let currentScrollCaptureInfo = {
  tabId: null,
  originalScrollY: 0,
  viewportHeight: 0,
  dpr: 0,
  overlap: 50, // pixels
  maxScrolls: 20,
  scrollCount: 0
};

function initiateScrollingScreenshot(tabId, options) {
  collectedScrollCaptures = [];
  chrome.scripting.executeScript({
    target: { tabId: tabId },
    func: () => ({
      scrollY: window.scrollY,
      scrollMaxY: document.documentElement.scrollHeight - window.innerHeight, // Or body
      viewportHeight: window.innerHeight,
      viewportWidth: window.innerWidth,
      dpr: window.devicePixelRatio || 1
    })
  }).then(results => {
    const pageInfo = results[0].result;
    currentScrollCaptureInfo = {
      tabId: tabId,
      originalScrollY: pageInfo.scrollY,
      currentScrollY: pageInfo.scrollY,
      scrollMaxY: pageInfo.scrollMaxY,
      viewportHeight: pageInfo.viewportHeight,
      viewportWidth: pageInfo.viewportWidth,
      dpr: pageInfo.dpr,
      overlap: 50,
      maxScrolls: 20,
      scrollCount: 0
    };
    // Notify content script to show "Scrolling..."
    chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification' });
    scrollAndCaptureNext();
  });
}

function scrollAndCaptureNext() {
  const { tabId, currentScrollY, scrollMaxY, viewportHeight, overlap, maxScrolls, scrollCount, dpr, viewportWidth } = currentScrollCaptureInfo;

  if (currentScrollY >= scrollMaxY || scrollCount >= maxScrolls) {
    // End of scrolling or max scrolls reached
    finalizeScrollingCapture();
    return;
  }

  // 1. Capture current view
  chrome.tabs.captureVisibleTab(null, { format: 'png', quality: 100 }, (dataUrl) => {
    if (chrome.runtime.lastError || !dataUrl) {
      console.error("Capture failed:", chrome.runtime.lastError);
      restoreScrollPosition(tabId, { scrollY: currentScrollCaptureInfo.originalScrollY });
      // Notify content script of failure
      chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed' });
      return;
    }

    collectedScrollCaptures.push({ dataUrl: dataUrl, scrollY: currentScrollY });

    // 2. Calculate next scroll position
    let nextScrollY = currentScrollY + viewportHeight - overlap;
    nextScrollY = Math.min(nextScrollY, scrollMaxY);

    currentScrollCaptureInfo.scrollCount++;

    if (nextScrollY <= currentScrollY && currentScrollY < scrollMaxY) { // Check if scroll will actually happen
        // If at the bottom and nextScrollY is not greater, but still not at scrollMaxY (edge case with small remaining scroll)
        // Force one last capture at the very bottom if not already there.
        if (currentScrollY < scrollMaxY) {
             nextScrollY = scrollMaxY; // Try to scroll to the absolute end
        } else {
             finalizeScrollingCapture();
             return;
        }
    }


    // 3. Scroll
    chrome.scripting.executeScript({
      target: { tabId: tabId },
      func: (scrollToY) => {
        window.scrollTo(0, scrollToY);
        return window.scrollY; // Return actual new scrollY
      },
      args: [nextScrollY]
    }).then(results => {
      const actualNewScrollY = results[0].result;
      // Update currentScrollY for the next iteration based on actual scroll
      currentScrollCaptureInfo.currentScrollY = actualNewScrollY;

      if (actualNewScrollY <= currentScrollY && actualNewScrollY < scrollMaxY) { // stuck
          console.log("Scrolling seems stuck or reached end.");
          finalizeScrollingCapture();
          return;
      }

      setTimeout(scrollAndCaptureNext, 300); // Delay for render
    }).catch(error => {
        console.error("Scroll execution failed:", error);
        restoreScrollPosition(tabId, { scrollY: currentScrollCaptureInfo.originalScrollY });
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed' });
    });
  });
}

function finalizeScrollingCapture() {
  const { tabId, originalScrollY, viewportWidth, viewportHeight, dpr } = currentScrollCaptureInfo;
  restoreScrollPosition(tabId, { scrollY: originalScrollY });

  if (collectedScrollCaptures.length === 0) {
    chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: 'No captures made.' });
    return;
  }

  // Stitching logic (simplified from mergeAndProcessTiles)
  const firstCapture = collectedScrollCaptures[0];
  const lastCapture = collectedScrollCaptures[collectedScrollCaptures.length - 1];

  // Calculate total height of the stitched image.
  // The image starts from firstCapture.scrollY and ends at lastCapture.scrollY + viewportHeight.
  const totalEffectiveScrollHeight = (lastCapture.scrollY + viewportHeight) - firstCapture.scrollY;

  const canvas = new OffscreenCanvas(viewportWidth * dpr, totalEffectiveScrollHeight * dpr);
  const ctx = canvas.getContext('2d');

  let loadedImages = 0;
  collectedScrollCaptures.forEach((capture, index) => {
    const img = new Image();
    img.onload = () => {
      // Calculate y position for this strip on the final canvas
      // The drawing y-offset is relative to the scroll position of the first capture
      const drawY = (capture.scrollY - firstCapture.scrollY) * dpr;
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, drawY, img.width, img.height);
      loadedImages++;
      if (loadedImages === collectedScrollCaptures.length) {
        canvas.convertToBlob({ type: 'image/png' }).then(blob => {
          const finalDataUrl = URL.createObjectURL(blob);
          // Save the final image
          saveScreenshot({ dataUrl: finalDataUrl, format: 'png', suffix: '_scrolling' }, (response) => {
            if (response.success) {
              chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureSuccess' });
            } else {
              chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: response.error });
            }
            URL.revokeObjectURL(finalDataUrl); // Clean up object URL
          });
        });
      }
    };
    img.onerror = () => {
        loadedImages++; // Count as loaded to avoid hanging
        console.error("Image load error for scroll capture.");
         if (loadedImages === collectedScrollCaptures.length) {
            // If this was the last one, try to finalize with what we have or report error
            chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: 'Image load error during stitching.' });
         }
    };
    img.src = capture.dataUrl;
  });
}

// (Need restoreScrollPosition and saveScreenshot functions)
```

This `background.js` approach seems more centralized and less prone to complex message passing loops. `content.js` will just be responsible for showing notifications.

**`popup.js` modifications:**
Add a new button:
```html
<button id="start-scrolling-screenshot" class="popup-button">
  <span data-i18n="popup_scrollScreenshot">滚动截屏</span>
</button>
```
Add event listener:
```javascript
const startScrollingScreenshotBtn = document.getElementById('start-scrolling-screenshot');
if (startScrollingScreenshotBtn) {
  startScrollingScreenshotBtn.addEventListener('click', function() {
    startScrollingScreenshotBtn.disabled = true;
    startScrollingScreenshotBtn.querySelector('span').textContent = getText('capturing'); // Assuming getText for i18n

    chrome.runtime.sendMessage({ action: 'initiateScrollingScreenshotFromPopup' });
    setTimeout(() => window.close(), 500);
  });
}
```

**`background.js` listener for this:**
```javascript
// Inside chrome.runtime.onMessage.addListener
else if (message.action === 'initiateScrollingScreenshotFromPopup') {
  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
    if (tabs.length > 0) {
      initiateScrollingScreenshot(tabs[0].id, {}); // options can be passed if needed
    }
  });
}
```

**`content.js` for notifications:**
```javascript
// Inside chrome.runtime.onMessage.addListener
else if (message.action === 'showScrollingNotification') {
  this.showNotification(I18nHelper.getNotificationText('processingScrollCapture') || "正在滚动截取长图...", 50000); // Long duration, will be removed by success/fail
} else if (message.action === 'scrollingCaptureSuccess') {
  this.showNotification(I18nHelper.getNotificationText('scrollCaptureSaved') || "长截图已保存!", 3000);
  // Potentially call this.end() or a cleanup specific to scrolling if needed
} else if (message.action === 'scrollingCaptureFailed') {
  const errorMsg = message.error || (I18nHelper.getNotificationText('scrollCaptureFailed') || "长截图失败");
  this.showNotification(errorMsg, 3000);
  // Potentially call this.end() or a cleanup
}
```
Add relevant i18n strings in `content.js` and `popup.js`.

The `simpleBackgroundRemoval` in `content.js` is quite complex. For scrolling screenshots, this isn't directly relevant but good to note its presence.

The crucial part is the `initiateScrollingScreenshot`, `scrollAndCaptureNext`, and `finalizeScrollingCapture` logic in `background.js`. `OffscreenCanvas` should be used for stitching if possible, as it's better for background tasks. The `saveScreenshot` function should be callable from `finalizeScrollingCapture`.

**Smart detection of scrollable element (Advanced):**
If we want to allow users to select a scrollable element:
1.  **`popup.js`:** When "Scrolling Screenshot" is clicked, and if a "select element" mode is desired, it sends a message like `initiateSelectScrollableElement` to `content.js`.
2.  **`content.js`:**
    *   Enters an element selection mode similar to `enableInspection()`.
    *   User clicks an element.
    *   `content.js` checks if the element is actually scrollable (`element.scrollHeight > element.clientHeight` and `getComputedStyle(element).overflowY` is 'auto' or 'scroll').
    *   If scrollable, it sends `action: 'startScrollingScreenshotForElement'` to `background.js` with element details (e.g., a unique selector for the element).
3.  **`background.js`:**
    *   The `initiateScrollingScreenshot` function would be modified.
    *   Instead of `window.scrollY` and `document.documentElement.scrollHeight`, it would use `chrome.scripting.executeScript` to get/set `element.scrollTop` and get `element.scrollHeight` for the specific element.
    *   Scrolling would also target that specific element: `element.scrollTop = newScrollYValue;`.

For the initial implementation, scrolling the main document (`window.scrollTo`) is simpler and covers many cases.

Let's review the `captureFullPageByTiles` in `background.js`. It already has a tile-based capture. It seems `targetArea` defines the overall region. The scrolling screenshots will always have `targetArea.width = viewportWidth` and `targetArea.left = 0` (relative to the scroll). The `targetArea.height` will be the full scrollable height.

The existing `captureFullPageByTiles` and `mergeAndProcessTiles` are quite sophisticated. The main adaptation for a vertical scrolling screenshot is to simplify the tiling to be purely vertical strips, where each "tile" is a viewport capture.

**Revised `initiateScrollingScreenshot` in `background.js`:**
The logic should determine the full scrollable height of the page first.

```javascript
// In background.js
async function initiateScrollingScreenshot(tabId, options) {
    collectedScrollCaptures = []; // Reset
    currentScrollCaptureInfo.tabId = tabId;
    currentScrollCaptureInfo.scrollCount = 0;
    currentScrollCaptureInfo.overlap = 50; // config
    currentScrollCaptureInfo.maxScrolls = 30; // config, safety limit

    try {
        // Get initial page dimensions and scroll state
        const [pageDetails] = await chrome.scripting.executeScript({
            target: { tabId },
            func: () => ({
                initialScrollY: window.scrollY,
                pageFullHeight: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight),
                viewportHeight: window.innerHeight,
                viewportWidth: window.innerWidth,
                dpr: window.devicePixelRatio || 1,
            }),
        });

        if (!pageDetails || !pageDetails.result) {
            throw new Error("Could not get page details.");
        }
        const { initialScrollY, pageFullHeight, viewportHeight, viewportWidth, dpr } = pageDetails.result;

        currentScrollCaptureInfo.originalScrollY = initialScrollY;
        currentScrollCaptureInfo.currentScrollY = initialScrollY;
        currentScrollCaptureInfo.pageFullHeight = pageFullHeight; // This is the total height we need to cover
        currentScrollCaptureInfo.viewportHeight = viewportHeight;
        currentScrollCaptureInfo.viewportWidth = viewportWidth;
        currentScrollCaptureInfo.dpr = dpr;

        // Scroll to top before starting if not already there
        if (initialScrollY > 0) {
            await chrome.scripting.executeScript({
                target: { tabId },
                func: () => window.scrollTo(0, 0),
            });
            currentScrollCaptureInfo.currentScrollY = 0; // Update current scroll Y
            await new Promise(resolve => setTimeout(resolve, 300)); // Wait for scroll and render
        }
        
        chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在准备滚动截图...' });
        await scrollAndCaptureNextIteration();

    } catch (error) {
        console.error("Error initiating scrolling screenshot:", error);
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: error.message });
        if (currentScrollCaptureInfo.originalScrollY !== undefined) {
             restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
        }
    }
}

async function scrollAndCaptureNextIteration() {
    const { tabId, currentScrollY, pageFullHeight, viewportHeight, overlap, maxScrolls, scrollCount, dpr, viewportWidth } = currentScrollCaptureInfo;

    if (currentScrollY + viewportHeight >= pageFullHeight || scrollCount >= maxScrolls) {
        // Capture the last part if needed (if currentScrollY is not already covering the end)
        // or if we've scrolled past the full height.
        if (scrollCount > 0 && currentScrollY < pageFullHeight ) { // Ensure we capture the very end
             await captureCurrentViewForScrolling();
        }
        finalizeScrollingCapture();
        return;
    }

    try {
        await captureCurrentViewForScrolling();

        currentScrollCaptureInfo.scrollCount++;
        const nextScrollYAttempt = currentScrollY + viewportHeight - overlap;
        
        const [scrollResult] = await chrome.scripting.executeScript({
            target: { tabId },
            func: (targetY) => {
                window.scrollTo(0, targetY);
                return window.scrollY;
            },
            args: [nextScrollYAttempt],
        });

        const newActualScrollY = scrollResult.result;

        if (newActualScrollY <= currentScrollY && newActualScrollY < pageFullHeight - viewportHeight) { // Stuck before end
            console.log("Scroll stuck or no change, finalizing.");
            await captureCurrentViewForScrolling(); // Capture the stuck view one last time
            finalizeScrollingCapture();
            return;
        }
        currentScrollCaptureInfo.currentScrollY = newActualScrollY;
        
        chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: `已截取 ${scrollCount + 1} 部分...` });
        setTimeout(scrollAndCaptureNextIteration, 300); // Delay for render

    } catch (error) {
        console.error("Error in scrollAndCaptureNextIteration:", error);
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: error.message });
        restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
    }
}

async function captureCurrentViewForScrolling() {
    const { tabId, currentScrollY } = currentScrollCaptureInfo;
    return new Promise((resolve, reject) => {
        chrome.tabs.captureVisibleTab(null, { format: 'png', quality: 100 }, (dataUrl) => {
            if (chrome.runtime.lastError || !dataUrl) {
                console.error("Capture failed:", chrome.runtime.lastError);
                reject(new Error(chrome.runtime.lastError?.message || "Capture failed"));
                return;
            }
            // Check if this capture is redundant (same scrollY as previous)
            const lastCap = collectedScrollCaptures[collectedScrollCaptures.length -1];
            if (!lastCap || lastCap.scrollY < currentScrollY) {
                collectedScrollCaptures.push({ dataUrl, scrollY: currentScrollY });
            } else if (lastCap && lastCap.scrollY === currentScrollY) {
                // Overwrite if it's the exact same scroll position, might be a refinement
                lastCap.dataUrl = dataUrl;
            }
            resolve();
        });
    });
}

async function finalizeScrollingCapture() {
    const { tabId, originalScrollY, viewportWidth, viewportHeight, dpr } = currentScrollCaptureInfo;

    // Restore scroll position
    await restoreScrollPosition(tabId, { scrollX: 0, scrollY: originalScrollY });

    if (collectedScrollCaptures.length === 0) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '未能截取任何图像。' });
        return;
    }

    console.log(`Stitching ${collectedScrollCaptures.length} captures.`);
    chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在合成长截图...' });

    // Deduplicate captures by scrollY, keeping the last one for a given scrollY
    const uniqueCaptures = [];
    const seenScrollY = new Set();
    for (let i = collectedScrollCaptures.length - 1; i >= 0; i--) {
        const capture = collectedScrollCaptures[i];
        if (!seenScrollY.has(capture.scrollY)) {
            uniqueCaptures.unshift(capture); // Add to beginning to maintain order
            seenScrollY.add(capture.scrollY);
        }
    }
    collectedScrollCaptures = uniqueCaptures;


    const firstCaptureScrollY = collectedScrollCaptures[0].scrollY;
    // The last relevant scroll position for height calculation is the scrollY of the last image.
    // The content of this image extends for viewportHeight.
    const lastCaptureScrollY = collectedScrollCaptures[collectedScrollCaptures.length - 1].scrollY;
    
    // Total height is from the top of the first capture to the bottom of the last visible part.
    const totalEffectiveScrollHeight = (lastCaptureScrollY + viewportHeight) - firstCaptureScrollY;

    const canvas = new OffscreenCanvas(Math.round(viewportWidth * dpr), Math.round(totalEffectiveScrollHeight * dpr));
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '无法创建画布用于合成图像。' });
        return;
    }
    ctx.imageSmoothingEnabled = false; // For sharper images

    let imagesProcessed = 0;
    for (const capture of collectedScrollCaptures) {
        try {
            const img = await createImageBitmapFromUrl(capture.dataUrl);
            const drawY = (capture.scrollY - firstCaptureScrollY) * dpr;
            // Ensure image width matches canvas width expectations (dpr applied)
            ctx.drawImage(img, 0, drawY, viewportWidth * dpr, viewportHeight * dpr);
            img.close(); // Release memory
            imagesProcessed++;

            if (imagesProcessed === collectedScrollCaptures.length) {
                const blob = await canvas.convertToBlob({ type: 'image/png', quality: 0.92 });
                const finalDataUrl = URL.createObjectURL(blob);
                
                saveScreenshot({ dataUrl: finalDataUrl, format: 'png', suffix: '_scrolling' }, (response) => {
                    URL.revokeObjectURL(finalDataUrl);
                    if (response.success) {
                        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureSuccess' });
                    } else {
                        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: response.error });
                    }
                });
                return; // Exit after successful processing of all images
            }
        } catch (error) {
            console.error("Error processing image for stitching:", error);
            // If one image fails, we might have to abort or try to continue
             imagesProcessed++; // Count as processed to avoid hanging
             if (imagesProcessed === collectedScrollCaptures.length) {
                 // If this was the last one, and it failed, report overall failure.
                 chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '合成图像时部分图片处理失败。' });
             }
        }
    }
}

// Helper to create ImageBitmap (preferred for OffscreenCanvas)
async function createImageBitmapFromUrl(dataUrl) {
    const response = await fetch(dataUrl);
    const blob = await response.blob();
    return await createImageBitmap(blob);
}
```
The `restoreScrollPosition` needs to be async or return a promise if it uses `executeScript`.
The `saveScreenshot` would also ideally be async if it's to be awaited, or its callback logic handled carefully.
The new I18n strings for content.js notifications will be:
`processingScrollCapture`: "正在滚动截取长图..."
`scrollCaptureSaved`: "长截图已保存!"
`scrollCaptureFailed`: "长截图失败"
`capturing`: "截取中..." (for popup button)
`popup_scrollScreenshot`: "滚动截屏" (for popup button text)

This refined flow in `background.js` using async/await should be more manageable.
The `pageFullHeight` calculation might need refinement. `document.documentElement.scrollHeight` is usually the most reliable for the entire page.
The condition `currentScrollY + viewportHeight >= pageFullHeight` indicates the bottom of the viewport has reached or passed the end of the scrollable content.
One final capture at `pageFullHeight - viewportHeight` might be needed if the last scroll step overshoots by a small amount, or simply capture and let the stitching crop. The current logic `(lastCapture.scrollY + viewportHeight) - firstCapture.scrollY` for `totalEffectiveScrollHeight` should handle the height correctly.
The stitching part `ctx.drawImage(img, 0, drawY, viewportWidth * dpr, viewportHeight * dpr);` assumes each capture is exactly `viewportWidth * dpr` by `viewportHeight * dpr`. `captureVisibleTab` should give this.

The maximum number of scrolls (`maxScrolls`) is a crucial safety net.
Consider adding a small random delay between captures if rate limiting becomes an issue, though `captureVisibleTab` is generally less restricted than `captureTab`.
The overlap helps ensure no missed strips if scrolling is not perfectly aligned with viewport height multiples.
Final check on `finalizeScrollingCapture`:
The `uniqueCaptures` logic is good.
The `totalEffectiveScrollHeight` calculation needs to be robust. If `pageFullHeight` from `initiateScrollingScreenshot` is accurate, then the canvas height could be `(pageFullHeight - initialScrollYAtTop) * dpr`.
However, relying on the captured strips: `(lastCapture.scrollY + viewportHeight - firstCaptureScrollY) * dpr` is better as it's based on actual captures.
The `saveScreenshot` function in `background.js` expects a `dataUrl`. `canvas.convertToBlob` -> `URL.createObjectURL(blob)` creates a blob URL, which is fine for `chrome.downloads.download`.

A key improvement: when scrolling, if `window.scrollTo(0, targetY)` results in `window.scrollY` being less than `targetY`, it means we've hit the actual bottom of the scrollable content. This actual `window.scrollY` should be used to determine if we're done.
My updated `scrollAndCaptureNextIteration` handles `newActualScrollY <= currentScrollY` as a "stuck" condition.
And the main stop condition is `currentScrollY + viewportHeight >= pageFullHeight`. If `pageFullHeight` is correctly determined as the true scrollable height of the document, this is good.

One edge case: If the page dynamically loads content as you scroll (infinite scroll), `pageFullHeight` might change. The `maxScrolls` limit is important here. A "smart" system might try to detect if new content consistently appears after scrolling, but that's much more complex. For now, a fixed `pageFullHeight` at the start is a reasonable approach.
The current approach scrolls to `0` first, then captures downwards. This simplifies `pageFullHeight` to mean the total document height.
The stitching is drawing each viewport-sized image strip onto a tall canvas. The y-offset `(capture.scrollY - firstCaptureScrollY) * dpr` correctly positions each strip. The `firstCaptureScrollY` will be `0` because we scroll to top first. So it simplifies to `capture.scrollY * dpr`.</details></think>

---

好的，很乐意为您实现这个滚动长截图功能。结合您插件目前的结构和风格，我们可以设计一个既智能又用户友好的滚动截图方案。

**核心思路：**

我们将采用一种“滚动与拍摄”的策略。后台脚本（`background.js`）将负责协调整个流程：控制页面滚动、触发单次视口截图、收集所有截图，最后将它们拼接成一张完整的长图。内容脚本（`content.js`）主要负责在页面上显示相关的提示信息。

**实现步骤和代码变更：**

**1. `popup/popup.html` 和 `popup/popup.js` (弹窗界面)**

*   **添加按钮**: 在 `popup.html` 中，我们添加一个新的按钮用于启动滚动截图。

    ```html
    // ... 其他按钮 ...
    <div class="mode-switch">
        <button id="normal-mode" class="mode-button active" data-i18n="popup_normalMode">常规截图</button>
        <button id="inspect-mode" class="mode-button" data-i18n="popup_inspectMode">智能识别</button>
        <button id="start-scrolling-screenshot" class="mode-button" data-i18n="popup_scrollScreenshot">滚动截屏</button> // 新增按钮
    </div>
    // ... 其他元素 ...
    ```

*   **`popup.js` 事件处理**:
    *   为新按钮添加点击事件监听。
    *   点击后，禁用按钮，显示“截取中...”，并向 `background.js` 发送消息以启动滚动截图流程。
    *   更新国际化文本，添加 `popup_scrollScreenshot: "滚动截屏"` 和 `capturing: "截取中..."` 等。

    ```javascript
    // popup.js
    // ... (引入 i18n, 获取其他DOM元素) ...
    const startScrollingScreenshotBtn = document.getElementById('start-scrolling-screenshot');

    document.addEventListener('DOMContentLoaded', function() {
        // ... (其他loadSettings, 事件监听) ...

        if (startScrollingScreenshotBtn) {
            startScrollingScreenshotBtn.addEventListener('click', function() {
                // 切换激活状态 (如果需要的话，类似 normal-mode 和 inspect-mode)
                document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                startScrollingScreenshotBtn.disabled = true;
                const spanElement = startScrollingScreenshotBtn.querySelector('span');
                if (spanElement) {
                    spanElement.textContent = getText('capturing') || '截取中...';
                } else {
                    startScrollingScreenshotBtn.textContent = getText('capturing') || '截取中...';
                }


                // 通知 background.js 启动滚动截图
                chrome.runtime.sendMessage({ action: 'initiateScrollingScreenshotFromPopup' });

                // 保存模式偏好（如果滚动截图也作为一种模式）
                // chrome.storage.sync.set({ activeMode: 'scrolling' }); // 可选

                setTimeout(() => {
                    window.close();
                }, 500);
            });
        }
        // ...
    });
    
    // 确保 i18n 更新函数包含新的 key
    // 在 updateI18nTexts 中更新按钮文本
    // 'popup_scrollScreenshot': '滚动截屏'
    // 'capturing': '截取中...'
    ```

**2. `background/background.js` (后台脚本)**

这是实现滚动截图的核心。我们将添加新的函数来控制滚动、捕获和拼接。

*   **消息监听**: 监听来自 `popup.js` 的 `initiateScrollingScreenshotFromPopup` 消息。
*   **新增全局变量**: 用于存储滚动截图过程中的状态和数据。
*   **`initiateScrollingScreenshot(tabId, options)`**:
    *   获取当前页面的初始滚动位置、总可滚动高度、视口尺寸和设备像素比。
    *   将页面滚动到顶部（`window.scrollTo(0,0)`）作为截图的起点。
    *   通知内容脚本显示“正在准备滚动截图...”的提示。
    *   开始第一个迭代的滚动和捕获。
*   **`scrollAndCaptureNextIteration()` (async)**:
    *   **停止条件**: 如果当前滚动位置加上视口高度已经达到或超过页面总高度，或者达到了最大滚动次数限制，则停止滚动并进入最终合成阶段。
    *   调用 `captureCurrentViewForScrolling()` 捕获当前视口。
    *   计算下一次滚动的目标位置（`currentScrollY + viewportHeight - overlap`，`overlap` 是一个小的重叠区域，比如 50px，以防止截图间出现缝隙）。
    *   执行滚动。
    *   如果滚动后实际位置没有变化（可能已到底部或卡住），则停止。
    *   更新当前滚动位置，并短暂延迟（例如 300ms）等待页面渲染完成，然后递归调用自身进行下一次迭代。
    *   通知内容脚本更新进度，例如“已截取 N 部分...”。
*   **`captureCurrentViewForScrolling()` (async)**:
    *   使用 `chrome.tabs.captureVisibleTab` 捕获当前可见区域。
    *   将获取到的 `dataUrl` 和当前的 `scrollY` 位置存入 `collectedScrollCaptures` 数组。
    *   处理截图失败的情况。
*   **`finalizeScrollingCapture()` (async)**:
    *   将页面滚动回原始位置。
    *   如果未收集到任何截图，则通知内容脚本失败。
    *   **图片拼接**:
        *   对 `collectedScrollCaptures` 按 `scrollY` 去重，保留每个滚动位置的最后一次截图。
        *   计算最终合成图像的总高度：`(最后一次截图的scrollY +  viewportHeight) - 第一次截图的scrollY`。宽度为 `viewportWidth`。所有尺寸需乘以 `dpr`。
        *   创建一个 `OffscreenCanvas` 用于在后台高效拼接图像。
        *   遍历所有收集到的截图：
            *   将 `dataUrl` 转换为 `ImageBitmap`。
            *   根据当前截图的 `scrollY`（相对于第一次截图的 `scrollY`）计算其在最终画布上的 `drawY` 位置。
            *   将 `ImageBitmap` 绘制到 `OffscreenCanvas` 上。
        *   所有图片绘制完成后，将 `OffscreenCanvas` 转换为 PNG blob。
        *   使用 `URL.createObjectURL(blob)` 生成临时的 `dataUrl`，然后调用现有的 `saveScreenshot` 函数保存。
        *   保存成功或失败后，通知内容脚本。
*   **辅助函数**:
    *   `createImageBitmapFromUrl(dataUrl)`: 将 `dataUrl` 转换为 `ImageBitmap`。
    *   `restoreScrollPosition(tabId, position)`: 恢复页面滚动位置。

```javascript
// background.js

// ... (import config, DEFAULT_SETTINGS, customShortcuts, loadCustomShortcuts) ...

let collectedScrollCaptures = [];
let currentScrollCaptureInfo = {
    tabId: null,
    originalScrollY: 0,
    currentScrollY: 0,
    pageFullHeight: 0,
    viewportHeight: 0,
    viewportWidth: 0,
    dpr: 1,
    overlap: 50, // px, for overlap between captures
    maxScrolls: 30, // Safety limit for number of scrolls
    scrollCount: 0
};

// ... (chrome.runtime.onInstalled, injectKeyboardListener, chrome.commands.onCommand) ...

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log("收到消息:", message.action);
    // ... (其他消息处理) ...
    if (message.action === 'initiateScrollingScreenshotFromPopup') {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs.length > 0 && tabs[0].id) {
                // 确保tabId有效
                if (tabs[0].url && (tabs[0].url.startsWith('chrome://') || tabs[0].url.startsWith('edge://') || tabs[0].url.startsWith('about:'))) {
                    console.log("无法在浏览器内部页面上启动滚动截图");
                    // 可以选择通过popup通知用户
                    return;
                }
                initiateScrollingScreenshot(tabs[0].id, {});
            } else {
                 console.error("无法获取活动标签页ID以启动滚动截图");
            }
        });
        sendResponse({ success: true, status: "Scrolling screenshot initiated" });
    }
    // ...
    return true; // Keep message channel open for async responses
});


async function initiateScrollingScreenshot(tabId, options) {
    collectedScrollCaptures = []; // Reset
    currentScrollCaptureInfo.tabId = tabId;
    currentScrollCaptureInfo.scrollCount = 0;
    currentScrollCaptureInfo.overlap = 50; // Configurable
    currentScrollCaptureInfo.maxScrolls = 30; // Configurable safety limit

    try {
        const [pageDetails] = await chrome.scripting.executeScript({
            target: { tabId },
            func: () => ({
                initialScrollY: window.scrollY,
                // More robust page height calculation
                pageFullHeight: Math.max(
                    document.body.scrollHeight, document.documentElement.scrollHeight,
                    document.body.offsetHeight, document.documentElement.offsetHeight,
                    document.body.clientHeight, document.documentElement.clientHeight
                ),
                viewportHeight: window.innerHeight,
                viewportWidth: window.innerWidth,
                dpr: window.devicePixelRatio || 1,
            }),
        });

        if (!pageDetails || !pageDetails.result) {
            throw new Error("无法获取页面详细信息。");
        }
        const { initialScrollY, pageFullHeight, viewportHeight, viewportWidth, dpr } = pageDetails.result;

        currentScrollCaptureInfo.originalScrollY = initialScrollY;
        currentScrollCaptureInfo.currentScrollY = initialScrollY; // Will be set to 0 after scroll to top
        currentScrollCaptureInfo.pageFullHeight = pageFullHeight;
        currentScrollCaptureInfo.viewportHeight = viewportHeight;
        currentScrollCaptureInfo.viewportWidth = viewportWidth;
        currentScrollCaptureInfo.dpr = dpr;

        // Scroll to top before starting
        if (initialScrollY > 0) {
            await chrome.scripting.executeScript({
                target: { tabId },
                func: () => window.scrollTo(0, 0),
            });
            currentScrollCaptureInfo.currentScrollY = 0;
            await new Promise(resolve => setTimeout(resolve, 350)); // Wait for scroll and render
        } else {
            currentScrollCaptureInfo.currentScrollY = 0; // Already at top
        }
        
        chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在准备滚动截图...' });
        await scrollAndCaptureNextIteration();

    } catch (error) {
        console.error("初始化滚动截图失败:", error);
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `初始化失败: ${error.message}` });
        if (currentScrollCaptureInfo.originalScrollY !== undefined) {
             await restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
        }
    }
}

async function scrollAndCaptureNextIteration() {
    const { tabId, currentScrollY, pageFullHeight, viewportHeight, overlap, maxScrolls, scrollCount } = currentScrollCaptureInfo;
    
    // Stop if viewport bottom is at or past page end, or max scrolls reached
    if (currentScrollY + viewportHeight >= pageFullHeight || scrollCount >= maxScrolls) {
        if (scrollCount > 0 && currentScrollY < pageFullHeight) { // Capture the last bit if not fully covered
            try {
                await captureCurrentViewForScrolling();
            } catch (e) { /* Log error, but proceed to finalize */ console.error("Failed to capture final view:", e); }
        }
        finalizeScrollingCapture();
        return;
    }

    try {
        await captureCurrentViewForScrolling();
        currentScrollCaptureInfo.scrollCount++;
        
        // Calculate next scroll position, ensuring it doesn't exceed pageFullHeight
        let nextScrollYAttempt = Math.min(currentScrollY + viewportHeight - overlap, pageFullHeight - viewportHeight);
        if (nextScrollYAttempt <= currentScrollY && currentScrollY < pageFullHeight - viewportHeight) { // Avoid getting stuck if calculation leads to no change
            nextScrollYAttempt = currentScrollY + 10; // Try a small scroll
            nextScrollYAttempt = Math.min(nextScrollYAttempt, pageFullHeight - viewportHeight);
        }


        const [scrollResult] = await chrome.scripting.executeScript({
            target: { tabId },
            func: (targetY) => {
                window.scrollTo(0, targetY);
                return window.scrollY; // Return new actual scrollY
            },
            args: [nextScrollYAttempt],
        });
        
        const newActualScrollY = scrollResult.result;

        // If scrolling didn't change significantly and we are not at the very end
        if (newActualScrollY <= currentScrollY && newActualScrollY < pageFullHeight - viewportHeight) {
            console.log("滚动卡住或已到达末尾，正在结束。");
            if(newActualScrollY < pageFullHeight - viewportHeight) { // Check if we need one last capture
                 await captureCurrentViewForScrolling(); // Capture the "stuck" view
            }
            finalizeScrollingCapture();
            return;
        }
        currentScrollCaptureInfo.currentScrollY = newActualScrollY;
        
        chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: `已截取 ${currentScrollCaptureInfo.scrollCount} 部分...` });
        await new Promise(resolve => setTimeout(resolve, 350)); // Delay for render
        await scrollAndCaptureNextIteration();

    } catch (error) {
        console.error("滚动和捕获迭代中发生错误:", error);
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `截图过程中出错: ${error.message}` });
        await restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
    }
}

async function captureCurrentViewForScrolling() {
    const { tabId, currentScrollY } = currentScrollCaptureInfo;
    return new Promise((resolve, reject) => {
        chrome.tabs.captureVisibleTab(null, { format: 'png', quality: 100 }, (dataUrl) => {
            if (chrome.runtime.lastError || !dataUrl) {
                console.error("捕获视口失败:", chrome.runtime.lastError);
                reject(new Error(chrome.runtime.lastError?.message || "捕获视口失败"));
                return;
            }
            
            const lastCapture = collectedScrollCaptures.length > 0 ? collectedScrollCaptures[collectedScrollCaptures.length - 1] : null;
            // Only add if it's a new scroll position to avoid redundant captures
            if (!lastCapture || lastCapture.scrollY < currentScrollY) {
                 collectedScrollCaptures.push({ dataUrl, scrollY: currentScrollY });
            } else if (lastCapture && lastCapture.scrollY === currentScrollY) {
                // If at the exact same scroll position, update with the latest capture (might be a retry)
                lastCapture.dataUrl = dataUrl;
            }
            resolve();
        });
    });
}

async function finalizeScrollingCapture() {
    const { tabId, originalScrollY, viewportWidth, viewportHeight, dpr } = currentScrollCaptureInfo;

    await restoreScrollPosition(tabId, { scrollX: 0, scrollY: originalScrollY });

    if (collectedScrollCaptures.length === 0) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '未能截取任何图像。' });
        return;
    }

    console.log(`准备合成 ${collectedScrollCaptures.length} 张截图。`);
    chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在合成长截图...' });

    // Deduplicate captures by scrollY, keeping the one with the largest scrollY if multiple exist for "close" positions (not strictly needed with current logic, but good practice)
    // Or simply ensure they are sorted by scrollY
    collectedScrollCaptures.sort((a, b) => a.scrollY - b.scrollY);
    
    const uniqueCaptures = [];
    if (collectedScrollCaptures.length > 0) {
        uniqueCaptures.push(collectedScrollCaptures[0]);
        for (let i = 1; i < collectedScrollCaptures.length; i++) {
            if (collectedScrollCaptures[i].scrollY > uniqueCaptures[uniqueCaptures.length - 1].scrollY) {
                uniqueCaptures.push(collectedScrollCaptures[i]);
            }
        }
    }
    collectedScrollCaptures = uniqueCaptures;


    if (collectedScrollCaptures.length === 0) { // Check again after potential deduplication
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '无有效图像用于合成。' });
        return;
    }

    const firstCaptureScrollY = collectedScrollCaptures[0].scrollY;
    const lastCapture = collectedScrollCaptures[collectedScrollCaptures.length - 1];
    const totalEffectiveScrollHeight = (lastCapture.scrollY + viewportHeight) - firstCaptureScrollY;

    const finalCanvasWidth = Math.round(viewportWidth * dpr);
    const finalCanvasHeight = Math.round(totalEffectiveScrollHeight * dpr);

    if (finalCanvasWidth <= 0 || finalCanvasHeight <= 0) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '计算的画布尺寸无效。' });
        return;
    }

    const canvas = new OffscreenCanvas(finalCanvasWidth, finalCanvasHeight);
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '无法创建画布用于合成图像。' });
        return;
    }
    ctx.imageSmoothingEnabled = true; 
    ctx.imageSmoothingQuality = "high";


    let imagesProcessed = 0;
    for (const capture of collectedScrollCaptures) {
        try {
            const img = await createImageBitmapFromUrl(capture.dataUrl);
            const drawY = Math.round((capture.scrollY - firstCaptureScrollY) * dpr);
            // Draw the image, ensuring it's scaled to the dpr-adjusted viewport size
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, drawY, Math.round(viewportWidth * dpr), Math.round(viewportHeight * dpr));
            img.close(); 
            imagesProcessed++;

            if (imagesProcessed === collectedScrollCaptures.length) {
                const blob = await canvas.convertToBlob({ type: 'image/png', quality: 0.95 }); // PNG quality is more about compression level
                const finalDataUrl = URL.createObjectURL(blob);
                
                saveScreenshot({ dataUrl: finalDataUrl, format: 'png', suffix: '_scrolling' }, (response) => {
                    URL.revokeObjectURL(finalDataUrl); // Clean up object URL
                    if (response.success) {
                        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureSuccess' });
                    } else {
                        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: response.error || "保存失败" });
                    }
                });
                return; 
            }
        } catch (error) {
            console.error("合成图像时处理单张图片失败:", error);
            imagesProcessed++; 
            if (imagesProcessed === collectedScrollCaptures.length) {
                 chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '合成图像时部分图片处理失败。' });
            }
        }
    }
     // Fallback if loop finishes due to errors before all images are processed and success path taken
    if (imagesProcessed < collectedScrollCaptures.length && collectedScrollCaptures.length > 0) {
        chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '未能成功合成所有图片部分。' });
    }
}

async function createImageBitmapFromUrl(dataUrl) {
    const response = await fetch(dataUrl);
    const blob = await response.blob();
    return await createImageBitmap(blob, { premultiplyAlpha: 'none', colorSpaceConversion: 'none' });
}

async function restoreScrollPosition(tabId, position) {
    try {
        await chrome.scripting.executeScript({
            target: { tabId: tabId },
            func: (posY) => {
                window.scrollTo(0, posY);
            },
            args: [position.scrollY]
        });
    } catch (e) {
        console.error("恢复滚动位置失败:", e);
    }
}

// ... (existing saveScreenshot, captureScreen, etc.)
```

**3. `content/content.js` (内容脚本)**

*   **消息监听**:
    *   `showScrollingNotification`: 显示一个长时间存在的通知（例如 "正在滚动截取长图..." 或 "已截取 N 部分..."）。这个通知会在成功或失败时被新的通知替换。
    *   `scrollingCaptureSuccess`: 显示 "长截图已保存!"。
    *   `scrollingCaptureFailed`: 显示错误信息。
*   **添加 I18n 字符串**:
    *   `processingScrollCapture`: "正在滚动截取长图..." (或者更动态的，如 "已截取 {0} 部分...")
    *   `scrollCaptureSaved`: "长截图已保存!"
    *   `scrollCaptureFailed`: "长截图失败" (或 "长截图失败: {0}" 用于显示具体错误)

```javascript
// content.js
// ... (var I18nHelper) ...

// 在 I18nHelper.getNotificationText 的 notifications 对象中添加:
// zh: {
//   ...
//   processingScrollCapture: "正在滚动截取长图...",
//   processingScrollCaptureProgress: "已截取 {0} 部分...", // 新增，用于进度
//   scrollCaptureSaved: "长截图已保存!",
//   scrollCaptureFailed: "长截图失败: {0}",
//   ...
// },
// en: {
//   ...
//   processingScrollCapture: "Processing scrolling screenshot...",
//   processingScrollCaptureProgress: "Captured {0} parts...", // 新增
//   scrollCaptureSaved: "Scrolling screenshot saved!",
//   scrollCaptureFailed: "Scrolling screenshot failed: {0}",
//   ...
// }
// (为其他语言也添加相应翻译)

class RatioScreenshot {
    // ... (constructor, existing methods) ...

    initMessageListener() {
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            try {
                console.log("内容脚本收到消息:", message);
                if (message.action === 'initiateScreenshot') {
                    // ... (existing logic)
                } 
                // ... (existing screenshotConfirm, screenshotCancel) ...
                else if (message.action === 'showScrollingNotification') {
                    // 移除之前的滚动通知（如果有）
                    if (this.scrollingNotification) {
                        this.scrollingNotification.remove();
                        this.scrollingNotification = null;
                    }
                    // 根据是否有进度信息，选择不同的文本
                    let notificationText = message.progressCount 
                        ? I18nHelper.getNotificationText('processingScrollCaptureProgress', message.progressCount)
                        : message.text || I18nHelper.getNotificationText('processingScrollCapture');

                    this.scrollingNotification = this.showNotification(notificationText, 60000); // 长时间显示，会被后续消息更新或移除
                    sendResponse({success: true});
                } else if (message.action === 'scrollingCaptureSuccess') {
                    if (this.scrollingNotification) this.scrollingNotification.remove();
                    this.showNotification(I18nHelper.getNotificationText('scrollCaptureSaved'), 3000);
                    this.end(); // 滚动截图完成后也调用end来清理
                    sendResponse({success: true});
                } else if (message.action === 'scrollingCaptureFailed') {
                    if (this.scrollingNotification) this.scrollingNotification.remove();
                    const errorText = message.error ? I18nHelper.getNotificationText('scrollCaptureFailed', message.error) : I18nHelper.getNotificationText('scrollCaptureFailed', '未知错误');
                    this.showNotification(errorText, 5000);
                    this.end(); // 滚动截图完成后也调用end来清理
                    sendResponse({success: true, error: message.error});
                }
                // ...
                return true;
            } catch (e) {
                console.error("处理消息时发生错误:", e);
                sendResponse({ success: false, error: e.message });
                return true;
            }
        });
    }

    // ... (其他方法)
}

// ... (实例化)
```

**智能性考虑：**

1.  **自动滚动到底部**: 上述逻辑通过比较 `currentScrollY + viewportHeight` 和 `pageFullHeight` 来判断是否到达底部。
2.  **重叠区域 (`overlap`)**: 确保截图之间有部分重叠，避免因页面元素动态加载或精确滚动问题导致的缝隙。
3.  **最大滚动次数 (`maxScrolls`)**: 防止在某些特殊页面（如无限滚动但检测不到底部的页面）中陷入死循环。
4.  **滚动到顶部开始**: 统一从页面顶部开始截图，简化了坐标计算和拼接逻辑。
5.  **错误处理与恢复**: 滚动或截图失败时，尝试恢复原始滚动位置并通知用户。
6.  **动态加载内容**: 当前方案对于“无限滚动”页面的处理是有限的（依赖 `maxScrolls`）。真正的智能检测无限滚动会复杂得多，需要分析 DOM 变化和网络请求。目前方案优先保证在常规长页面上的可用性。
7.  **固定/粘性元素（Fixed/Sticky Headers/Footers）**: `chrome.tabs.captureVisibleTab` 会捕获视口所见内容，包括固定元素。这意味着在拼接长图时，这些固定元素可能会在每个“片段”中重复出现。处理这个问题比较复杂，常见方法有：
    *   在截图前尝试通过脚本临时隐藏这些固定元素（`display: none`），截图后再恢复。这需要准确识别这些元素，有一定风险改变页面布局。
    *   在拼接时，识别并只保留第一张截图中的 Header 和最后一张截图中的 Footer（如果适用）。这需要图像分析能力。
    *   **目前方案未包含对固定元素的特殊处理，它们会被重复截取。** 这是后续可以优化的方向。

**代码风格和集成：**

*   新功能将集成到现有 `background.js` 的消息处理和函数结构中。
*   UI 提示将使用 `content.js` 中现有的 `showNotification` 方法，保持风格一致。
*   代码注释和日志将帮助理解和调试。

这个方案提供了一个比较完整的滚动长截图功能框架。实际实现时，需要仔细测试各种边界条件和不同类型的网页。

---

_**User**_

执行吧

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants to apply the an extensive set of changes to implement a scrolling screenshot feature. I need to:
1.  Modify `popup/popup.html` to add a new button.
2.  Modify `popup/popup.js` to handle the new button's click event, send a message to the background script, and update i18n texts.
3.  Modify `background/background.js` with the core logic for scrolling screenshots:
    *   Add message listeners for `initiateScrollingScreenshotFromPopup`.
    *   Add new global variables for state management.
    *   Implement `initiateScrollingScreenshot`, `scrollAndCaptureNextIteration`, `captureCurrentViewForScrolling`, and `finalizeScrollingCapture`.
    *   Implement helper functions `createImageBitmapFromUrl` and `restoreScrollPosition`.
4.  Modify `content/content.js` to handle new messages for notifications (`showScrollingNotification`, `scrollingCaptureSuccess`, `scrollingCaptureFailed`) and update i18n strings.

I will break this down into multiple `edit_file` calls.

**Plan:**

1.  **Edit `popup/popup.html`**: Add the "滚动截屏" button.
2.  **Edit `popup/popup.js`**:
    *   Add event listener for the new button.
    *   Implement logic to send `initiateScrollingScreenshotFromPopup` message.
    *   Update i18n related parts (assuming `getText` and `updateI18nTexts` are correctly set up by the user to handle new keys).
3.  **Edit `content/content.js`**:
    *   Add new i18n strings for scrolling notifications to `I18nHelper`.
    *   Update `initMessageListener` to handle `showScrollingNotification`, `scrollingCaptureSuccess`, and `scrollingCaptureFailed` messages.
    *   Initialize `this.scrollingNotification = null;` in the constructor.
4.  **Edit `background/background.js`**: This is the most complex part.
    *   Add global variables: `collectedScrollCaptures`, `currentScrollCaptureInfo`.
    *   Add message listener for `initiateScrollingScreenshotFromPopup`.
    *   Implement `initiateScrollingScreenshot`.
    *   Implement `scrollAndCaptureNextIteration`.
    *   Implement `captureCurrentViewForScrolling`.
    *   Implement `finalizeScrollingCapture`.
    *   Implement `createImageBitmapFromUrl`.
    *   Implement `restoreScrollPosition` (or ensure it's robust if a similar one exists).

Let's start with `popup/popup.html`.</details></think>

---

Okay, I will proceed with implementing the scrolling screenshot feature.

First, I'll add the "滚动截屏" (Scrolling Screenshot) button to your `popup/popup.html` file.

---

```diff
    
    <div class="mode-switch">
-     <button id="normal-mode" class="active" data-i18n="normalMode"><i class="fas fa-crop-alt"></i> 普通模式</button>
-     <button id="inspect-mode" data-i18n="inspectMode"><i class="fas fa-magic"></i> 智能模式</button>
+     <button id="normal-mode" class="mode-button active" data-i18n="popup_normalMode">常规截图</button>
+     <button id="inspect-mode" class="mode-button" data-i18n="popup_inspectMode">智能识别</button>
+     <button id="start-scrolling-screenshot" class="mode-button" data-i18n="popup_scrollScreenshot"><span>滚动截屏</span></button>
    </div>
    
```

---

Next, I'll modify `popup/popup.js` to handle the new button's functionality and related UI updates. This includes adding an event listener for the "滚动截屏" button, sending a message to the background script to initiate the scrolling screenshot, and ensuring the button text updates to "截取中..." when clicked. I'll also assume that your `getText` and `updateI18nTexts` functions in `utils/i18n.js` will be updated to include the new internationalization keys like `popup_scrollScreenshot: "滚动截屏"` and `capturing: "截取中..."`.

---

```diff
    const normalModeBtn = document.getElementById('normal-mode');
    const inspectModeBtn = document.getElementById('inspect-mode');
+   const startScrollingScreenshotBtn = document.getElementById('start-scrolling-screenshot');
    const shortcutKey = document.querySelector('[data-command="screenshot_start"]');
    const quickShareBtn = document.getElementById('quick-share');
```

```diff
    normalModeBtn.addEventListener('click', function() {
      isInspectMode = false;
-     normalModeBtn.classList.add('active');
-     inspectModeBtn.classList.remove('active');
+     document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
+     this.classList.add('active');
      ratioSelect.disabled = false;
      
```

```diff
    inspectModeBtn.addEventListener('click', function() {
      isInspectMode = true;
-     inspectModeBtn.classList.add('active');
-     normalModeBtn.classList.remove('active');
+     document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
+     this.classList.add('active');
      ratioSelect.value = 'free';
      ratioSelect.disabled = true;
```

```diff
      chrome.storage.sync.set({ isInspectMode: true });
    });
+   
+   // 滚动截图按钮事件监听
+   if (startScrollingScreenshotBtn) {
+     startScrollingScreenshotBtn.addEventListener('click', function() {
+         document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
+         this.classList.add('active');
+         
+         startScrollingScreenshotBtn.disabled = true;
+         // 尝试获取按钮内的span元素来更新文本，如果不存在则直接更新按钮文本
+         const spanElement = startScrollingScreenshotBtn.querySelector('span');
+         if (spanElement) {
+             spanElement.textContent = getText('capturing') || '截取中...';
+         } else {
+             startScrollingScreenshotBtn.textContent = getText('capturing') || '截取中...';
+         }
+ 
+         // 通知 background.js 启动滚动截图
+         chrome.runtime.sendMessage({ action: 'initiateScrollingScreenshotFromPopup' });
+ 
+         // 可选: 保存滚动截图模式为活动模式 (如果将来需要此状态)
+         // chrome.storage.sync.set({ activeMode: 'scrolling' });
+ 
+         setTimeout(() => {
+             window.close();
+         }, 500);
+     });
+   }
    
    // 监听比例选择改变
```

---

Now, I'll update `content/content.js`. This involves:
1.  Adding new i18n strings for scrolling-related notifications to the `I18nHelper` object.
2.  Updating the `initMessageListener` method in the `RatioScreenshot` class to handle new messages:
    *   `showScrollingNotification`: To display or update a persistent notification about the scrolling capture progress.
    *   `scrollingCaptureSuccess`: To show a success message and clean up.
    *   `scrollingCaptureFailed`: To show an error message and clean up.
3.  Initializing `this.scrollingNotification = null;` in the constructor of `RatioScreenshot` to keep track of the persistent notification element.

---

```diff
            qrSuccess: "二维码解析成功，已复制到剪贴板",
            qrNoQRFound: "未检测到有效的二维码",
-           qrError: "二维码解析失败: {0}"
+           qrError: "二维码解析失败: {0}",
+           processingScrollCapture: "正在滚动截取长图...", // 新增
+           processingScrollCaptureProgress: "已截取 {0} 部分...", // 新增
+           scrollCaptureSaved: "长截图已保存!", // 新增
+           scrollCaptureFailed: "长截图失败: {0}" // 新增
          },
          en: {
```

```diff
            qrSuccess: "QR code decoded successfully, copied to clipboard",
            qrNoQRFound: "No valid QR code detected",
-           qrError: "QR code decoding failed: {0}"
+           qrError: "QR code decoding failed: {0}",
+           processingScrollCapture: "Processing scrolling screenshot...", // 新增
+           processingScrollCaptureProgress: "Captured {0} parts...", // 新增
+           scrollCaptureSaved: "Scrolling screenshot saved!", // 新增
+           scrollCaptureFailed: "Scrolling screenshot failed: {0}" // 新增
          },
          es: {
```

```diff
            qrSuccess: "Código QR decodificado correctamente, copiado al portapapeles",
            qrNoQRFound: "No se detectó un código QR válido",
-           qrError: "Error al decodificar código QR: {0}"
+           qrError: "Error al decodificar código QR: {0}",
+           processingScrollCapture: "Procesando captura de desplazamiento...", // 新增
+           processingScrollCaptureProgress: "Capturadas {0} partes...", // 新增
+           scrollCaptureSaved: "¡Captura de desplazamiento guardada!", // 新增
+           scrollCaptureFailed: "Error en la captura de desplazamiento: {0}" // 新增
          },
          ar: {
```

```diff
            qrSuccess: "تم فك رمز QR بنجاح، تم نسخه إلى الملصق",
            qrNoQRFound: "لم يتم الكشف عن رمز QR صالح",
-           qrError: "فشل فك رمز QR: {0}"
+           qrError: "فشل فك رمز QR: {0}",
+           processingScrollCapture: "جاري معالجة لقطة الشاشة المتحركة...", // 新增
+           processingScrollCaptureProgress: "تم التقاط {0} أجزاء...", // 新增
+           scrollCaptureSaved: "تم حفظ لقطة الشاشة المتحركة!", // 新增
+           scrollCaptureFailed: "فشل حفظ لقطة الشاشة المتحركة: {0}" // 新增
          },
          de: {
```

```diff
            qrSuccess: "QR-Code erfolgreich dekodiert, in die Zwischenablage kopiert",
            qrNoQRFound: "Kein gültiges QR-Code erkannt",
-           qrError: "QR-Code-Dekodierung fehlgeschlagen: {0}"
+           qrError: "QR-Code-Dekodierung fehlgeschlagen: {0}",
+           processingScrollCapture: "Scrolling Screenshot wird verarbeitet...", // 新增
+           processingScrollCaptureProgress: "{0} Teile erfasst...", // 新增
+           scrollCaptureSaved: "Scrolling Screenshot gespeichert!", // 新增
+           scrollCaptureFailed: "Scrolling Screenshot fehlgeschlagen: {0}" // 新增
          },
          pt: {
```

```diff
            qrSuccess: "QR Code decodificado com sucesso, copiado para a área de transferência",
            qrNoQRFound: "Nenhum QR Code válido detectado",
-           qrError: "Falha ao decodificar QR Code: {0}"
+           qrError: "Falha ao decodificar QR Code: {0}",
+           processingScrollCapture: "Processando captura de tela com rolagem...", // 新增
+           processingScrollCaptureProgress: "{0} partes capturadas...", // 新增
+           scrollCaptureSaved: "Captura de tela com rolagem salva!", // 新增
+           scrollCaptureFailed: "Falha na captura de tela com rolagem: {0}" // 新增
          },
          ja: {
```

```diff
            qrSuccess: "QRコードが正常に解析されました、クリップボードにコピーされました",
            qrNoQRFound: "有効なQRコードが検出されませんでした",
-           qrError: "QRコードの解析に失敗しました: {0}"
+           qrError: "QRコードの解析に失敗しました: {0}",
+           processingScrollCapture: "スクロールスクリーンショットを処理中...", // 新增
+           processingScrollCaptureProgress: "{0} 個のパーツをキャプチャしました...", // 新增
+           scrollCaptureSaved: "スクロールスクリーンショットが保存されました！", // 新增
+           scrollCaptureFailed: "スクロールスクリーンショットの保存に失敗しました: {0}" // 新增
          },
          fr: {
```

```diff
            qrSuccess: "QR Code décodé avec succès, copié dans le presse-papiers",
            qrNoQRFound: "Aucun QR Code valide détecté",
-           qrError: "Échec du décodage du QR Code: {0}"
+           qrError: "Échec du décodage du QR Code: {0}",
+           processingScrollCapture: "Traitement de la capture d'écran déroulante...", // 新增
+           processingScrollCaptureProgress: "{0} parties capturées...", // 新增
+           scrollCaptureSaved: "Capture d'écran déroulante enregistrée !", // 新增
+           scrollCaptureFailed: "Échec de la capture d'écran déroulante : {0}" // 新增
          },
          ko: {
```

```diff
            qrSuccess: "二维码解析成功，已复制到剪贴板",
            qrNoQRFound: "未检测到有效的二维码",
-           qrError: "二维码解析失败: {0}"
+           qrError: "二维码解析失败: {0}",
+           processingScrollCapture: "正在滚动截取长图...", // 新增
+           processingScrollCaptureProgress: "已截取 {0} 部分...", // 新增
+           scrollCaptureSaved: "长截图已保存!", // 新增
+           scrollCaptureFailed: "长截图失败: {0}" // 新增
          },
          en: {
```

```diff
            qrSuccess: "QR code decoded successfully, copied to clipboard",
            qrNoQRFound: "No valid QR code detected",
-           qrError: "QR code decoding failed: {0}"
+           qrError: "QR code decoding failed: {0}",
+           processingScrollCapture: "Processing scrolling screenshot...", // 新增
+           processingScrollCaptureProgress: "Captured {0} parts...", // 新增
+           scrollCaptureSaved: "Scrolling screenshot saved!", // 新增
+           scrollCaptureFailed: "Scrolling screenshot failed: {0}" // 新增
          },
          es: {
```

```diff
            qrSuccess: "Código QR decodificado correctamente, copiado al portapapeles",
            qrNoQRFound: "No se detectó un código QR válido",
-           qrError: "Error al decodificar código QR: {0}"
+           qrError: "Error al decodificar código QR: {0}",
+           processingScrollCapture: "Procesando captura de desplazamiento...", // 新增
+           processingScrollCaptureProgress: "Capturadas {0} partes...", // 新增
+           scrollCaptureSaved: "¡Captura de desplazamiento guardada!", // 新增
+           scrollCaptureFailed: "Error en la captura de desplazamiento: {0}" // 新增
          },
          ar: {
```

```diff
            qrSuccess: "تم فك رمز QR بنجاح، تم نسخه إلى الملصق",
            qrNoQRFound: "لم يتم الكشف عن رمز QR صالح",
-           qrError: "فشل فك رمز QR: {0}"
+           qrError: "فشل فك رمز QR: {0}",
+           processingScrollCapture: "جاري معالجة لقطة الشاشة المتحركة...", // 新增
+           processingScrollCaptureProgress: "تم التقاط {0} أجزاء...", // 新增
+           scrollCaptureSaved: "تم حفظ لقطة الشاشة المتحركة!", // 新增
+           scrollCaptureFailed: "فشل حفظ لقطة الشاشة المتحركة: {0}" // 新增
          },
          de: {
```

```diff
            qrSuccess: "QR-Code erfolgreich dekodiert, in die Zwischenablage kopiert",
            qrNoQRFound: "Kein gültiges QR-Code erkannt",
-           qrError: "QR-Code-Dekodierung fehlgeschlagen: {0}"
+           qrError: "QR-Code-Dekodierung fehlgeschlagen: {0}",
+           processingScrollCapture: "Scrolling Screenshot wird verarbeitet...", // 新增
+           processingScrollCaptureProgress: "{0} Teile erfasst...", // 新增
+           scrollCaptureSaved: "Scrolling Screenshot gespeichert!", // 新增
+           scrollCaptureFailed: "Scrolling Screenshot fehlgeschlagen: {0}" // 新增
          },
          pt: {
```

```diff
            qrSuccess: "QR Code decodificado com sucesso, copiado para a área de transferência",
            qrNoQRFound: "Nenhum QR Code válido detectado",
-           qrError: "Falha ao decodificar QR Code: {0}"
+           qrError: "Falha ao decodificar QR Code: {0}",
+           processingScrollCapture: "Processando captura de tela com rolagem...", // 新增
+           processingScrollCaptureProgress: "{0} partes capturadas...", // 新增
+           scrollCaptureSaved: "Captura de tela com rolagem salva!", // 新增
+           scrollCaptureFailed: "Falha na captura de tela com rolagem: {0}" // 新增
          },
          ja: {
```

```diff
            qrSuccess: "QRコードが正常に解析されました、クリップボードにコピーされました",
            qrNoQRFound: "有効なQRコードが検出されませんでした",
-           qrError: "QRコードの解析に失敗しました: {0}"
+           qrError: "QRコードの解析に失敗しました: {0}",
+           processingScrollCapture: "スクロールスクリーンショットを処理中...", // 新增
+           processingScrollCaptureProgress: "{0} 個のパーツをキャプチャしました...", // 新增
+           scrollCaptureSaved: "スクロールスクリーンショットが保存されました！", // 新增
+           scrollCaptureFailed: "スクロールスクリーンショットの保存に失敗しました: {0}" // 新增
          },
          fr: {
```

```diff
            qrSuccess: "QR Code décodé avec succès, copié dans le presse-papiers",
            qrNoQRFound: "Aucun QR Code valide détecté",
-           qrError: "Échec du décodage du QR Code: {0}"
+           qrError: "Échec du décodage du QR Code: {0}",
+           processingScrollCapture: "Traitement de la capture d'écran déroulante...", // 新增
+           processingScrollCaptureProgress: "{0} parties capturées...", // 新增
+           scrollCaptureSaved: "Capture d'écran déroulante enregistrée !", // 新增
+           scrollCaptureFailed: "Échec de la capture d'écran déroulante : {0}" // 新增
          }
        };
```

```diff
        this.highlightElement = null;
        this.currentElement = null;
+       this.scrollingNotification = null; // 新增: 用于追踪滚动截图通知
        
        // 现有属性
```

```diff
              }
            }
+           // 新增: 处理滚动截图相关的通知
+           else if (message.action === 'showScrollingNotification') {
+             // 移除之前的滚动通知（如果有）
+             if (this.scrollingNotification) {
+                 try {
+                     this.scrollingNotification.remove();
+                 } catch (e) { console.warn("移除旧滚动通知失败", e); }
+                 this.scrollingNotification = null;
+             }
+             // 根据是否有进度信息，选择不同的文本
+             let notificationText = message.progressCount 
+                 ? I18nHelper.getNotificationText('processingScrollCaptureProgress', message.progressCount)
+                 : message.text || I18nHelper.getNotificationText('processingScrollCapture');
+ 
+             this.scrollingNotification = this.showNotification(notificationText, 60000); // 长时间显示，会被后续消息更新或移除
+             sendResponse({success: true});
+           } else if (message.action === 'scrollingCaptureSuccess') {
+               if (this.scrollingNotification) {
+                   try {
+                       this.scrollingNotification.remove();
+                   } catch (e) { console.warn("移除滚动成功通知失败", e); }
+                   this.scrollingNotification = null;
+               }
+               this.showNotification(I18nHelper.getNotificationText('scrollCaptureSaved'), 3000);
+               this.end(); // 滚动截图完成后也调用end来清理
+               sendResponse({success: true});
+           } else if (message.action === 'scrollingCaptureFailed') {
+               if (this.scrollingNotification) {
+                   try {
+                       this.scrollingNotification.remove();
+                   } catch (e) { console.warn("移除滚动失败通知失败", e); }
+                   this.scrollingNotification = null;
+               }
+               const errorText = message.error 
+                   ? I18nHelper.getNotificationText('scrollCaptureFailed', message.error) 
+                   : I18nHelper.getNotificationText('scrollCaptureFailed', '未知错误');
+               this.showNotification(errorText, 5000);
+               this.end(); // 滚动截图失败后也调用end来清理
+               sendResponse({success: true, error: message.error}); // 即使失败也响应success:true，因为消息已处理
+           }
            return true;
          } catch (e) {
```

---

Finally, I'll modify `background/background.js`. This is the most substantial part and includes:
1.  Adding global variables `collectedScrollCaptures` and `currentScrollCaptureInfo` for state management during scrolling capture.
2.  Adding a message listener for `initiateScrollingScreenshotFromPopup` to start the process.
3.  Implementing the `initiateScrollingScreenshot` function to get page details and start the capture iterations.
4.  Implementing the `scrollAndCaptureNextIteration` function to recursively scroll and capture parts of the page.
5.  Implementing `captureCurrentViewForScrolling` to capture the visible tab portion and store it.
6.  Implementing `finalizeScrollingCapture` to stitch the captured images together using `OffscreenCanvas` and save the result.
7.  Implementing helper functions:
    *   `createImageBitmapFromUrl` to convert data URLs to `ImageBitmap` objects for drawing on the canvas.
    *   `restoreScrollPosition` to scroll the page back to its original position after capture.

---

```diff
  // 自定义快捷键配置
  let customShortcuts = {};
+ 
+ // 新增: 滚动截图相关全局变量
+ let collectedScrollCaptures = [];
+ let currentScrollCaptureInfo = {
+     tabId: null,
+     originalScrollY: 0,
+     currentScrollY: 0,
+     pageFullHeight: 0,
+     viewportHeight: 0,
+     viewportWidth: 0,
+     dpr: 1,
+     overlap: 50, // px, for overlap between captures
+     maxScrolls: 30, // Safety limit for number of scrolls
+     scrollCount: 0
+ };
  
  // 加载自定义快捷键
```

```diff
      startScreenshotProcess(message.options || {});
    }
-   
+   // 新增: 处理来自弹窗的滚动截图启动命令
+   else if (message.action === 'initiateScrollingScreenshotFromPopup') {
+     chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
+         if (tabs.length > 0 && tabs[0].id) {
+             // 确保tabId有效，并且不是特殊页面
+             if (tabs[0].url && (tabs[0].url.startsWith('chrome://') || tabs[0].url.startsWith('edge://') || tabs[0].url.startsWith('about:'))) {
+                 console.log("无法在浏览器内部页面上启动滚动截图");
+                 // 可以选择通过popup或其他方式通知用户，这里仅作日志记录
+                 sendResponse({ success: false, error: "无法在特殊页面上启动滚动截图" });
+                 return;
+             }
+             initiateScrollingScreenshot(tabs[0].id, {}); // options可以根据需要传递
+             sendResponse({ success: true, status: "滚动截图流程已启动" });
+         } else {
+              console.error("无法获取活动标签页ID以启动滚动截图");
+              sendResponse({ success: false, error: "无法获取活动标签页ID" });
+         }
+     });
+     return true; // 保持异步
+   }
    // 处理屏幕捕获命令
    else if (message.action === 'captureScreen') {
```

```diff
    chrome.scripting.executeScript({
      target: { tabId: tabId },
-     func: (position) => {
-       window.scrollTo({
-         left: position.scrollX,
-         top: position.scrollY,
-         behavior: 'auto' // 使用即时滚动
-       });
+     func: (posY) => {
+       window.scrollTo(0, posY);
      },
-     args: [position]
+     args: [position.scrollY]
    }).catch(error => {
      console.error("恢复滚动位置失败:", error);
```

```diff
    // 必须返回true以保持sendResponse有效
    return true;
+ }
+ 
+ // 新增: 启动滚动截图流程的函数
+ async function initiateScrollingScreenshot(tabId, options) {
+     collectedScrollCaptures = []; // 重置收集的截图
+     currentScrollCaptureInfo.tabId = tabId;
+     currentScrollCaptureInfo.scrollCount = 0;
+     currentScrollCaptureInfo.overlap = options.overlap || 50; 
+     currentScrollCaptureInfo.maxScrolls = options.maxScrolls || 30;
+ 
+     try {
+         const [pageDetails] = await chrome.scripting.executeScript({
+             target: { tabId },
+             func: () => ({
+                 initialScrollY: window.scrollY,
+                 pageFullHeight: Math.max(
+                     document.body.scrollHeight, document.documentElement.scrollHeight,
+                     document.body.offsetHeight, document.documentElement.offsetHeight,
+                     document.body.clientHeight, document.documentElement.clientHeight
+                 ),
+                 viewportHeight: window.innerHeight,
+                 viewportWidth: window.innerWidth,
+                 dpr: window.devicePixelRatio || 1,
+             }),
+         });
+ 
+         if (!pageDetails || !pageDetails.result) {
+             throw new Error("无法获取页面详细信息。");
+         }
+         const { initialScrollY, pageFullHeight, viewportHeight, viewportWidth, dpr } = pageDetails.result;
+ 
+         currentScrollCaptureInfo.originalScrollY = initialScrollY;
+         currentScrollCaptureInfo.currentScrollY = 0; // 将在滚动到顶部后更新
+         currentScrollCaptureInfo.pageFullHeight = pageFullHeight;
+         currentScrollCaptureInfo.viewportHeight = viewportHeight;
+         currentScrollCaptureInfo.viewportWidth = viewportWidth;
+         currentScrollCaptureInfo.dpr = dpr;
+ 
+         // 开始前滚动到页面顶部
+         await chrome.scripting.executeScript({
+             target: { tabId },
+             func: () => window.scrollTo(0, 0),
+         });
+         currentScrollCaptureInfo.currentScrollY = 0; // 确认当前滚动位置为0
+         await new Promise(resolve => setTimeout(resolve, 350)); // 等待滚动和页面渲染
+         
+         chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在准备滚动截图...' });
+         await scrollAndCaptureNextIteration();
+ 
+     } catch (error) {
+         console.error("初始化滚动截图失败:", error);
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `初始化失败: ${error.message}` });
+         if (currentScrollCaptureInfo.originalScrollY !== undefined) {
+              await restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
+         }
+     }
+ }
+ 
+ // 新增: 递归滚动和捕获下一部分
+ async function scrollAndCaptureNextIteration() {
+     const { tabId, currentScrollY, pageFullHeight, viewportHeight, overlap, maxScrolls, scrollCount } = currentScrollCaptureInfo;
+     
+     // 停止条件: 视口底部到达或超过页面底部，或达到最大滚动次数
+     if (currentScrollY + viewportHeight >= pageFullHeight || scrollCount >= maxScrolls) {
+         // 如果因为滚动次数到达上限而停止，但页面未完全滚动完，尝试捕获最后一部分
+         if (scrollCount >= maxScrolls && currentScrollY + viewportHeight < pageFullHeight) {
+             try {
+                 await captureCurrentViewForScrolling(); // 捕获当前视口作为最后一部分
+             } catch (e) { 
+                 console.warn("捕获最后视口失败 (已达最大滚动次数):", e); 
+             }
+         } else if (scrollCount > 0 && currentScrollY < pageFullHeight && collectedScrollCaptures.length > 0) {
+           // 确保在正常结束前，如果最后一部分未完全覆盖视口，也捕获它
+           const lastCapturedY = collectedScrollCaptures[collectedScrollCaptures.length -1].scrollY;
+           if (currentScrollY > lastCapturedY || collectedScrollCaptures.length === 0 ) {
+              try {
+                  await captureCurrentViewForScrolling();
+              } catch (e) { console.warn("捕获最终视图失败:", e); }
+           }
+         }
+         finalizeScrollingCapture();
+         return;
+     }
+ 
+     try {
+         await captureCurrentViewForScrolling();
+         currentScrollCaptureInfo.scrollCount++;
+         
+         let nextScrollYAttempt = Math.min(currentScrollY + viewportHeight - overlap, pageFullHeight - viewportHeight);
+         // 防止滚动停滞或无法到达最底部的小块区域
+         if (nextScrollYAttempt <= currentScrollY && currentScrollY < pageFullHeight - viewportHeight) { 
+             nextScrollYAttempt = Math.min(currentScrollY + Math.max(10, overlap), pageFullHeight - viewportHeight); 
+         }
+         if (nextScrollYAttempt < 0) nextScrollYAttempt = 0; // Ensure not scrolling to negative
+ 
+ 
+         const [scrollResult] = await chrome.scripting.executeScript({
+             target: { tabId },
+             func: (targetY) => {
+                 window.scrollTo(0, targetY);
+                 return window.scrollY; 
+             },
+             args: [nextScrollYAttempt],
+         });
+         
+         const newActualScrollY = scrollResult.result;
+ 
+         // 如果滚动没有显著变化且未到达页面底部，则停止
+         if (newActualScrollY <= currentScrollY && newActualScrollY < pageFullHeight - viewportHeight) {
+             console.log("滚动卡住或已到达可滚动末尾，正在结束。 当前Y:", newActualScrollY, "之前Y:", currentScrollY);
+             // 再次捕获当前视口，确保最后一部分被捕获
+              if (newActualScrollY < pageFullHeight - viewportHeight && collectedScrollCaptures.length > 0) {
+                 const lastCapturedY = collectedScrollCaptures[collectedScrollCaptures.length-1].scrollY;
+                 if(newActualScrollY > lastCapturedY) {
+                   try {
+                       await captureCurrentViewForScrolling(); 
+                   } catch(e){ console.warn("捕获卡住视图失败", e);}
+                 }
+             }
+             finalizeScrollingCapture();
+             return;
+         }
+         currentScrollCaptureInfo.currentScrollY = newActualScrollY;
+         
+         chrome.tabs.sendMessage(tabId, { 
+             action: 'showScrollingNotification', 
+             text: `已截取 ${currentScrollCaptureInfo.scrollCount} 部分...`, 
+             progressCount: currentScrollCaptureInfo.scrollCount 
+         });
+         await new Promise(resolve => setTimeout(resolve, 350)); 
+         await scrollAndCaptureNextIteration();
+ 
+     } catch (error) {
+         console.error("滚动和捕获迭代中发生错误:", error);
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `截图过程中出错: ${error.message}` });
+         await restoreScrollPosition(tabId, { scrollX: 0, scrollY: currentScrollCaptureInfo.originalScrollY });
+     }
+ }
+ 
+ // 新增: 捕获当前视口用于滚动截图
+ async function captureCurrentViewForScrolling() {
+     const { tabId, currentScrollY } = currentScrollCaptureInfo;
+     return new Promise((resolve, reject) => {
+         chrome.tabs.captureVisibleTab(null, { format: 'png', quality: 100 }, (dataUrl) => {
+             if (chrome.runtime.lastError || !dataUrl) {
+                 console.error("捕获视口失败:", chrome.runtime.lastError);
+                 reject(new Error(chrome.runtime.lastError?.message || "捕获视口失败"));
+                 return;
+             }
+             
+             const lastCapture = collectedScrollCaptures.length > 0 ? collectedScrollCaptures[collectedScrollCaptures.length - 1] : null;
+             // 只有当滚动位置真正发生变化时才添加新的截图，或这是第一张截图
+             if (!lastCapture || currentScrollY > lastCapture.scrollY) {
+                  collectedScrollCaptures.push({ dataUrl, scrollY: currentScrollY });
+             } else if (lastCapture && currentScrollY === lastCapture.scrollY) {
+                 // 如果滚动位置相同（可能是重试或卡住），用最新的替换
+                 lastCapture.dataUrl = dataUrl;
+             }
+             resolve();
+         });
+     });
+ }
+ 
+ // 新增: 完成滚动截图并合成图像
+ async function finalizeScrollingCapture() {
+     const { tabId, originalScrollY, viewportWidth, viewportHeight, dpr, pageFullHeight } = currentScrollCaptureInfo;
+ 
+     await restoreScrollPosition(tabId, { scrollX: 0, scrollY: originalScrollY });
+ 
+     if (collectedScrollCaptures.length === 0) {
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '未能截取任何图像。' });
+         return;
+     }
+ 
+     console.log(`准备合成 ${collectedScrollCaptures.length} 张截图。`);
+     chrome.tabs.sendMessage(tabId, { action: 'showScrollingNotification', text: '正在合成长截图...' });
+ 
+     collectedScrollCaptures.sort((a, b) => a.scrollY - b.scrollY);
+     
+     const uniqueCaptures = [];
+     if (collectedScrollCaptures.length > 0) {
+         uniqueCaptures.push(collectedScrollCaptures[0]);
+         for (let i = 1; i < collectedScrollCaptures.length; i++) {
+             // 确保scrollY严格递增，避免因微小差异导致重复
+             if (collectedScrollCaptures[i].scrollY > uniqueCaptures[uniqueCaptures.length - 1].scrollY + 5) { // 5px容差
+                 uniqueCaptures.push(collectedScrollCaptures[i]);
+             }
+         }
+     }
+     collectedScrollCaptures = uniqueCaptures;
+ 
+     if (collectedScrollCaptures.length === 0) {
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: '无有效图像用于合成。' });
+         return;
+     }
+ 
+     const firstCaptureScrollY = collectedScrollCaptures[0].scrollY;
+     const lastCapture = collectedScrollCaptures[collectedScrollCaptures.length - 1];
+     // 计算总高度时，应考虑到最后一帧可能并未填满整个视口，或者页面实际高度可能小于 (lastScrollY + viewportHeight)
+     const totalEffectiveScrollHeight = Math.min(lastCapture.scrollY + viewportHeight, pageFullHeight) - firstCaptureScrollY;
+ 
+     const finalCanvasWidth = Math.round(viewportWidth * dpr);
+     const finalCanvasHeight = Math.round(totalEffectiveScrollHeight * dpr);
+ 
+     if (finalCanvasWidth <= 0 || finalCanvasHeight <= 0) {
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `计算的画布尺寸无效: ${finalCanvasWidth}x${finalCanvasHeight}` });
+         return;
+     }
+ 
+     try {
+         const canvas = new OffscreenCanvas(finalCanvasWidth, finalCanvasHeight);
+         const ctx = canvas.getContext('2d');
+         if (!ctx) {
+             throw new Error('无法创建OffscreenCanvas上下文。');
+         }
+         ctx.imageSmoothingEnabled = true; 
+         ctx.imageSmoothingQuality = "high";
+ 
+         let imagesProcessed = 0;
+         for (const capture of collectedScrollCaptures) {
+             const img = await createImageBitmapFromUrl(capture.dataUrl);
+             const drawY = Math.round((capture.scrollY - firstCaptureScrollY) * dpr);
+             // 确保绘制不超过画布边界
+             const drawHeight = Math.min(Math.round(viewportHeight * dpr), finalCanvasHeight - drawY);
+             if (drawHeight > 0) {
+                 ctx.drawImage(img, 0, 0, img.width, img.height, 0, drawY, finalCanvasWidth, drawHeight);
+             }
+             img.close(); 
+             imagesProcessed++;
+         }
+ 
+         if (imagesProcessed > 0) {
+             const blob = await canvas.convertToBlob({ type: 'image/png', quality: 0.95 });
+             const finalDataUrl = URL.createObjectURL(blob);
+             
+             saveScreenshot({ dataUrl: finalDataUrl, format: 'png', suffix: '_scrolling' }, (response) => {
+                 URL.revokeObjectURL(finalDataUrl); 
+                 if (response.success) {
+                     chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureSuccess' });
+                 } else {
+                     chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: response.error || "保存失败" });
+                 }
+             });
+         } else {
+              throw new Error('没有图像被成功处理和绘制。');
+         }
+ 
+     } catch (error) {
+         console.error("合成图像时出错:", error);
+         chrome.tabs.sendMessage(tabId, { action: 'scrollingCaptureFailed', error: `合成失败: ${error.message}` });
+     }
+ }
+ 
+ // 新增: 从dataUrl创建ImageBitmap
+ async function createImageBitmapFromUrl(dataUrl) {
+     const response = await fetch(dataUrl);
+     const blob = await response.blob();
+     // 优化：指定premultiplyAlpha和colorSpaceConversion有助于性能和一致性
+     return await createImageBitmap(blob, { premultiplyAlpha: 'none', colorSpaceConversion: 'none' });
+ }
+ 
+ // 新增: 恢复页面滚动位置
+ async function restoreScrollPosition(tabId, position) {
+     try {
+         await chrome.scripting.executeScript({
+             target: { tabId: tabId },
+             func: (posY) => {
+                 window.scrollTo(0, posY);
+             },
+             args: [position.scrollY]
+         });
+     } catch (e) {
+         console.error("恢复滚动位置失败:", e);
+         // 不再这里发送消息，因为可能在错误处理流程中调用
+     }
  } 
```

---

The scrolling screenshot feature has now been implemented across `popup/popup.html`, `popup/popup.js`, `content/content.js`, and `background/background.js`.

**Summary of Changes:**

*   **Popup Interface:** A "滚动截屏" (Scrolling Screenshot) button has been added to the popup. Clicking it initiates the scrolling capture process.
*   **Content Script (`content.js`):**
    *   Handles new messages from the background script to display notifications about the scrolling capture progress (e.g., "正在滚动截取长图...", "已截取 N 部分..."), success ("长截图已保存!"), or failure ("长截图失败: {error}").
    *   Appropriate i18n strings have been added.
*   **Background Script (`background/background.js`):**
    *   The core logic for scrolling capture resides here.
    *   It listens for the `initiateScrollingScreenshotFromPopup` message.
    *   `initiateScrollingScreenshot`: Initializes the process by getting page dimensions, scrolling to the top.
    *   `scrollAndCaptureNextIteration`: Recursively scrolls the page down by one viewport height (minus a small overlap), captures the visible area using `chrome.tabs.captureVisibleTab`, and repeats until the bottom of the page or a maximum scroll limit is reached.
    *   `captureCurrentViewForScrolling`: Captures the current view and stores the `dataUrl` along with its `scrollY` position.
    *   `finalizeScrollingCapture`: Once all parts are captured, it sorts the collected images by their scroll position, calculates the total dimensions, and uses an `OffscreenCanvas` to stitch them together into a single PNG image. The `dpr` (device pixel ratio) is considered for correct scaling. The final image is then saved using the existing `saveScreenshot` function.
    *   Helper functions `createImageBitmapFromUrl` (to convert dataURLs to ImageBitmaps for canvas drawing) and `restoreScrollPosition` (to return the page to its original scroll state) have been added.
    *   Error handling and notifications to the content script are included throughout the process.

**Important Considerations and Potential Next Steps:**

*   **Fixed/Sticky Elements:** As discussed, fixed or sticky headers/footers will currently be repeated in each captured segment. Addressing this would require more advanced techniques like attempting to hide them via script injection before each capture or post-processing the image to remove them.
*   **Infinite Scrolling Pages:** The current implementation has a `maxScrolls` limit to prevent getting stuck. True intelligent detection for "load more" buttons or infinite scroll mechanisms would be a significant enhancement.
*   **Dynamic Content/Layout Shifts:** Pages where content loads or shifts significantly during scrolling might lead to stitching artifacts. The delay between scroll and capture helps, but complex cases might still be problematic.
*   **Performance for Very Long Pages:** Capturing and stitching a very large number of images can be memory and CPU intensive. The `OffscreenCanvas` helps, but extremely long pages could still pose challenges.
*   **User Options:** You might consider adding options for:
    *   Overlap amount.
    *   Delay between scrolls.
    *   Maximum height/number of scrolls.
*   **Testing:** Thorough testing on various websites with different layouts, scrolling behaviors, and fixed elements is crucial.

You should now be able to test the implemented scrolling screenshot functionality. Remember to update your `utils/i18n.js` file with the new translation keys mentioned in the code for `popup.js` and `content.js` to ensure all text displays correctly in different languages.

---

